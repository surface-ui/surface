defmodule Mix.Tasks.Compile.Surface do
  @moduledoc """
  Generate CSS and JS/TS assets for components.

  ## Setup

  Update `mix.exs`, adding the `:surface` compiler to the list of compilers:

  ```elixir
  def project do
    [
      ...,
      compilers: [:phoenix] ++ Mix.compilers() ++ [:surface]
    ]
  end
  ```

  ## Configuration (optional)

  The Surface compiler provides some options for custom configuration in your `config/dev.exs`.

  ### Options

  * `generate_assets` - instructs the compiler to generate components' css and js files.
    Set it to `false` when developing a library of components that doesn't require any CSS
    style nor JS hooks. Default is `true`.

  * `generate_definitions` - instructs the compiler to generate components' definitions for
    language servers. Default is `true`.

  * `hooks_output_dir` - defines the folder where the compiler generates the JS hooks files.
    Default is `./assets/js/_hooks/`.

  * `css_output_file` - defines the css file where the compiler generates the code.
    Default is `./assets/css/_components.css`.

  * `enable_variants` [experimental] - instructs the compiler to generate tailwind variants based
    on props/data. Currently, only Tailwind variants are supported. Default is `false`.
    See more in the "Enabling CSS variants" section below.

  * `variants_output_file` [experimental] - if `enable_variants` is `true`, defines the config file where
    the compiler generates the scoped variants. Currently, only Tailwind variants are supported.
    Default is `./assets/css/_variants.js`.

  * `variants_prefix` [experimental] - defines a prefix for all variants generated by the compiler.
    Default is `@`.

  ### Example

      config :surface, :compiler,
        hooks_output_dir: "assets/js/surface",
        css_output_file: "assets/css/surface.css",
        enable_variants: true,
        variants_prefix: "s-"

  ### Enabling CSS variants

  By setting `enable_variants` to `true`, we instruct the compiler to generate tailwind
  variants based on props/data. All variants are generated in the `variants_output_file`,
  which defaults to `./assets/css/_variants.js`.

  > **NOTE**: This feature is still experimental and available for feedback.
  > Therefore, the API might change in the next Surface minor version. It's also
  > currently only available for Tailwind.

  To make the generated variants available in your templates, you need to set up the
  project's `tailwind.config.js` to add the `variants_output_file` as
  a preset. Example:

      module.exports = {
        presets: [
          require('./css/_variants.js')
        ],
        ...
      }

  ## Defining CSS variants

  In order to define CSS variants for your templates, you can use the `css_variant`
  option, which is available for both, `prop` and `data`.

  ### Example

      prop loading, :boolean, css_variant: true
      prop size, :string, values: ["small", "medium", "large"], css_variant: true

  Depending on the type of the assign you're defining, a set of default variants will
  be automatically available in your tamplates and be used directly in any `class`
  attribute. By default, all variants names will start with the `@` prefix. If needed,
  you can change it by setting the `variants_prefix` option.

  ### Example

      <button class="@loading:opacity-75 @size-small:text-sm @size-medium:text-base @size-large:text-lg">
        Submit
      </button>

  ## Customizing variants' names

  As mentioned in the previous section, each variant name generated bu the compiler
  will start with a prefix (default is `@`) followed by its base name. Most of the time,
  you probably want to stick with the default base name, however there are cases when
  renaming it may be more intuitive. For instance:

      # Name it as `@inactive` instead of `@not-active`
      prop active, :boolean, css_variant: [false: "inactive"]

      # Name it `@valid` and `@invalid` instead of `@has-errors` and `@no-errors`
      data errors, :list, css_variant: [has_items: "invalid", no_items: "valid"]

      # Name it `@small`, `@medium` and `@large` instead of `@size-small`, `@size-medium` and `@size-large`
      prop size, :string, values: ["small", "medium", "large"], css_variant: [prefix: ""]

  As you can see, the value of `css_variant` option can be either a boolean or a keyword
  list of options.

  By passing `true`, the compiler generates variants according to the default values
  for each option based to the name and type of the related assign. All available options for each type
  are listed below.

  ### Options for `:boolean`

  * `:true` - the base name of the variant when the value is truthy. Default is the assign name.
  * `:false` - the base name of the variant when the value is falsy. Default is `not-[assign-name]`.

  ### Options for enumerables, e.g. `:list`, `:map` and `:mapset`

  * `:has_items` - the base name of the variant when the value list has items.
    Default is `has-[assign-name]`
  * `:no_items` - the base name of the variant when the value is empty or `nil`.
    Default is `no-[assign-name]`

  ### Options for `:string`, `:atom` and `:integer` defining `values` or `values!`

  * `:prefix` - the prefix of the variant's base name generated for each value listed in `values` or `values!`.
    Default is `[assign-name]-`.

  ### Options for other types

  * `:not_nil` - the base name of the variant when the value is not `nil`.
    Default is the assign name.
  * `:nil` - the base name of the variant when the value is `nil`.
    Default is `no-[assign-name]`.

  """

  use Mix.Task
  @recursive true

  alias Mix.Task.Compiler.Diagnostic

  @switches [
    return_errors: :boolean,
    warnings_as_errors: :boolean
  ]

  @assets_opts [
    :generate_assets,
    :hooks_output_dir,
    :css_output_file,
    :enable_variants,
    :variants_output_file,
    :variants_prefix
  ]

  @definitions_opts [
    :generate_definitions
  ]

  @doc false
  def run(args) do
    # Do nothing if it's a dependency. We only have to run it once for the main project
    if "--from-mix-deps-compile" in args do
      {:noop, []}
    else
      {compile_opts, _argv, _err} = OptionParser.parse(args, switches: @switches)
      opts = Application.get_env(:surface, :compiler, [])
      asset_opts = Keyword.take(opts, @assets_opts)
      definitions_opts = Keyword.take(opts, @definitions_opts)

      {surface_components, project_surface_components, components_specs} =
        all_components_metadata() |> build_components_and_specs()

      [
        Mix.Tasks.Compile.Surface.ValidateComponents.validate(project_surface_components),
        Mix.Tasks.Compile.Surface.AssetGenerator.run(surface_components, asset_opts),
        Mix.Tasks.Compile.Surface.Definitions.run(components_specs, definitions_opts)
      ]
      |> List.flatten()
      |> handle_diagnostics(compile_opts)
    end
  end

  @doc false
  def handle_diagnostics(diagnostics, compile_opts) do
    case diagnostics do
      [] ->
        {:noop, []}

      diagnostics ->
        if !compile_opts[:return_errors], do: print_diagnostics(diagnostics)
        status = status(compile_opts[:warnings_as_errors], diagnostics)

        {status, diagnostics}
    end
  end

  defp print_diagnostics(diagnostics) do
    for %Diagnostic{message: message, severity: severity, file: file, position: position} <- diagnostics do
      print_diagnostic(message, severity, file, position)
    end
  end

  if Version.match?(System.version(), ">= 1.14.0") do
    defp print_diagnostic(message, :warning, file, {line, col}) do
      IO.warn(message, file: file, line: line, column: col)
    end
  end

  # TODO: Remove this clause in Surface v0.13 and set required elixir to >= v1.14
  defp print_diagnostic(message, :warning, file, line) do
    rel_file = file |> Path.relative_to_cwd() |> to_charlist()
    IO.warn(message, [{nil, :__FILE__, 1, [file: rel_file, line: line]}])
  end

  defp print_diagnostic(message, :error, file, line) do
    error = IO.ANSI.format([:red, "error: "])

    stacktrace =
      "  #{file}" <>
        if(line, do: ":#{line}", else: "")

    IO.puts(:stderr, [error, message, ?\n, stacktrace])
  end

  defp status(warnings_as_errors, diagnostics) do
    cond do
      Enum.any?(diagnostics, &(&1.severity == :error)) -> :error
      warnings_as_errors && Enum.any?(diagnostics, &(&1.severity == :warning)) -> :error
      true -> :ok
    end
  end

  @doc false
  def build_components_and_specs(meta_list) do
    project_app = Mix.Project.config()[:app]

    Enum.reduce(meta_list, {[], [], []}, fn meta, {components, project_components, specs} ->
      # TODO: Check if it's faster to retrieve the source directly from the file's chunk and add to meta
      {mod, _, _, _, _} = meta
      source = Path.relative_to_cwd(to_string(mod.module_info()[:compile][:source]))

      {specs, privates} = add_functions(meta, specs, source)
      add_component(meta, components, project_components, specs, source, project_app, privates)
    end)
  end

  defp add_component(
         {_, _surface_component? = true, _, _, _} = meta,
         components,
         project_components,
         specs,
         source,
         project_app,
         privates
       ) do
    {mod, _, _, aliases, imports} = meta
    project_component? = Application.get_application(mod) == project_app

    components = [mod | components]

    project_components =
      if project_component? do
        [mod | project_components]
      else
        project_components
      end

    spec = %{
      type: :surface,
      module: inspect(mod),
      docs: get_doc(mod),
      props: get_props(mod),
      source: source,
      privates: privates,
      aliases: map_aliases(aliases),
      imports: components_from_imports(imports)
      # TODO: line
    }

    {components, project_components, [spec | specs]}
  end

  defp add_component(_meta, components, project_components, specs, _source, _project_app, _privates) do
    {components, project_components, specs}
  end

  defp add_functions({mod, _, _has_function_components? = true, _, _}, specs, source) do
    function_components = mod.__components__()

    docs =
      if function_components != [] do
        get_functions_docs(mod)
      else
        %{}
      end

    Enum.reduce(function_components, {specs, []}, fn {func, func_spec}, {specs, privates} ->
      spec = %{
        type: func_spec.kind,
        module: inspect(mod),
        func: func,
        docs: docs[func],
        attrs: attrs_to_specs(func_spec.attrs),
        source: source,
        line: func_spec.line
      }

      case func_spec.kind do
        :def -> {[spec | specs], privates}
        :defp -> {specs, [spec | privates]}
      end
    end)
  end

  defp add_functions(_meta, specs, _source) do
    {specs, []}
  end

  defp all_components_metadata do
    :ok = Application.ensure_loaded(Mix.Project.config()[:app])
    {:ok, dirs} = :file.list_dir(~c"#{Mix.Project.build_path()}/lib")
    apps = Enum.map(dirs, fn dir -> :"#{dir}" end)

    for app <- apps,
        maybe_has_component?(app),
        {dir, files} = app_beams_dir_and_files(app),
        file <- files,
        List.starts_with?(file, ~c"Elixir.") do
      :filename.join(dir, file)
    end
    |> Enum.chunk_every(50)
    |> Task.async_stream(&extract_components_metadata/1, ordered: false)
    # Check if it's faster to use `|> Stream.map(fn {:ok, v} -> v end)` and then unfold recursively when
    # generating the 3 different lists
    |> Enum.flat_map(fn {:ok, result} -> result end)
  end

  @doc false
  def extract_components_metadata(files) do
    Enum.reduce(files, [], fn file, acc ->
      {:ok, {mod, [{:attributes, attrs}, {:exports, exports}]}} = :beam_lib.chunks(file, [:attributes, :exports])
      component_type = Keyword.get(attrs, :component_type)
      surface_component? = component_type != nil

      {aliases, imports} =
        if surface_component? do
          {Keyword.get(attrs, :surface_aliases, []), Keyword.get(attrs, :surface_imports, [])}
        else
          {[], []}
        end

      has_function_components? = Keyword.get(exports, :__components__) == 0

      if surface_component? or has_function_components? do
        [{mod, component_type != nil, has_function_components?, aliases || [], imports || []} | acc]
      else
        acc
      end
    end)
  end

  defp map_aliases(aliases) do
    Map.new(aliases, fn {key, value} ->
      {inspect(key), inspect(value)}
    end)
  end

  defp components_from_imports(surface_imports) do
    for {mod, imports} <- surface_imports,
        function_exported?(mod, :__components__, 0),
        components = mod.__components__(),
        func <- imports,
        Map.has_key?(components, func),
        into: %{} do
      {func, "#{inspect(mod)}.#{func}"}
    end
  end

  defp attrs_to_specs(attrs) do
    Enum.map(attrs, fn attr ->
      %{
        line: attr.line,
        name: attr.name,
        type: inspect(attr.type),
        doc: attr.doc,
        required: attr.required
      }
    end)
  end

  defp app_beams_dir_and_files(app) do
    dir =
      app
      |> Application.app_dir()
      |> Path.join("ebin")
      |> String.to_charlist()

    {:ok, files} = :file.list_dir(dir)
    {dir, files}
  end

  # We may need to do this recursively down the deps
  defp maybe_has_component?(app) do
    apps_with_components = [:phoenix_live_view, :surface]

    if app in apps_with_components do
      true
    else
      deps_apps = Application.spec(app)[:applications] || []
      Enum.any?(deps_apps, fn dep -> dep in apps_with_components end)
    end
  end

  defp get_doc(module) do
    case Code.fetch_docs(module) do
      {:docs_v1, _moduledoc_anno, _language, "text/markdown", %{"en" => docs}, _meta, _docs} ->
        docs

      _ ->
        nil
    end
  end

  defp get_functions_docs(module) do
    case Code.fetch_docs(module) do
      {:docs_v1, _moduledoc_anno, _language, "text/markdown", _mod_docs, _meta, func_docs} ->
        for {{:function, func, 1}, _line, _sig, %{"en" => doc}, _meta} <- func_docs, into: %{} do
          {func, doc}
        end

      _ ->
        %{}
    end
  end

  defp get_props(module) do
    if ensure_loaded?(module) and function_exported?(module, :__props__, 0) do
      for prop <- module.__props__(), prop.type != :children do
        %{
          name: "#{to_string(prop.name)}",
          type: prop.type,
          doc: prop.doc,
          opts: "#{inspect(prop.type)}#{format_opts(prop.opts_ast)}",
          line: prop.line
        }
      end
    else
      []
    end
  end

  defp format_opts(opts_ast) do
    if opts_ast == [] do
      ""
    else
      str =
        opts_ast
        |> Macro.to_string()
        |> String.slice(1..-2//1)

      ", " <> str
    end
  end

  defp ensure_loaded?(Elixir), do: false
  defp ensure_loaded?(mod), do: match?({:module, _}, Code.ensure_compiled(mod))
end
